{"categories":[{"title":"java","uri":"https://huayuye.github.io/blog/categories/java/"},{"title":"中间件","uri":"https://huayuye.github.io/blog/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"title":"工具","uri":"https://huayuye.github.io/blog/categories/%E5%B7%A5%E5%85%B7/"},{"title":"算法","uri":"https://huayuye.github.io/blog/categories/%E7%AE%97%E6%B3%95/"}],"posts":[{"content":"前言\n今天使用nginx做负载，在上传图片时，一直报500错误（Internal Server Error 500）， 开始已为是程序问题，但是在本地上传是没有问题的。 所以就往nginx的配置方面想了\n一、原来的配置  #user root; worker_processes 1; worker_rlimit_nofile 102400; events { worker_connections 65535; use epoll; multi_accept on; } http { include mime.types; default_type application/octet-stream; log_format main '[$content_type]--[$remote_addr] -$remote_user [$time_local] \u0026quot;[$request]\u0026quot; ' '[$status] $body_bytes_sent [$request_body] \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; sendfile on; tcp_nopush on; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 8m; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; fastcgi_intercept_errors on; proxy_headers_hash_max_size 51200; proxy_headers_hash_bucket_size 6400; proxy_buffer_size 128k; proxy_buffers 32 128k; proxy_busy_buffers_size 128k; #keepalive_timeout 0; keepalive_timeout 10; tcp_nodelay on; server_tokens off; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml application/json text/json text/xml; gzip_vary on; #sendfile on; #tcp_nopush on; #keepalive_timeout 0; #keepalive_timeout 65; #gzip on; #Load config files from the /etc/nginx/conf.d directory #The default server is in conf.d/default.conf include /root/nginx/conf.d/*.conf; }  二、解决方案 1、方案一\n（1）在/etc/security/limits.conf 添加配置\n soft nofile 65535 hard nofile 65535  （2）在nginx中配置\nworker_rlimit_nofile 65535\n（我原配置也有配）, 结果没有用\n2、方案二\n（1）在nginx上配置\nclient_body_buffer_size #使用默认设置，8k或者16k client_header_buffer_size #设置得比较大  我的原配置也有配置,这也没解决我的问题\n3、方案三\n修改nginx中user,我这里修改为root，结果令我意外的是，居然可以上传了,至此解决了我得问题\n三、nginx 和 user 和 大小之间的关系 后续补上\n","id":0,"section":"posts","summary":"前言 今天使用nginx做负载，在上传图片时，一直报500错误（Internal Server Error 500）， 开始已为是程序问题，但是在本地上传是没有问题的。","tags":["nginx"],"title":"Nginx上传文件500","uri":"https://huayuye.github.io/blog/2021/11/nginx-file-500/","year":"2021"},{"content":"一、服务启动报错 ERROR com.rabbitmq.client.impl.ForgivingExceptionHandler - An unexpected connection driver error occured java.net.SocketException: socket closed  二、根据错误显示，大概是MQ的问题： 1、开始以为是 Virtual Hosts / 下的用户没远程登录权限 结果设置还是没用\n2、后来一看发现这个 Virtual Hosts / 没启用，点击启用后 发现启动失败了\n error,{not_a_dets_file recovery.dets  3、失败的原因就是这个文件（recovery.dets）出问题了，直接删除，重启。\n文件之所以出错，应该是磁盘空间满了，而MQ服务又没退出，才导致了recovery.dets文件损坏。\nRabbitMQ从3.7.0版本开始所有的消息数据到放在msg_stores/vhosts目录下，每个vhost单独放在一个子目录，每个子目录以 (vhost名字+哈希值).vhost命名，每个vhost分开存储\nC:\\Users\\bingdeng\\AppData\\Roaming\\RabbitMQ\\db\\rabbit@bingdeng-mnesia\\msg_stores\\vhosts\\628WB79CIFDYO9LJI6DKMI09L\\recovery.dets  ","id":1,"section":"posts","summary":"一、服务启动报错 ERROR com.rabbitmq.client.impl.ForgivingExceptionHandler - An unexpected connection driver error occured java.net.SocketException: socket closed 二、根据错误显示，大概是MQ的问题： 1、开始以为是 Virtual Hosts / 下的用户没远程登录权限 结果设置还是没用 2、后","tags":["mq"],"title":"Mq Error, Recovery.Dets","uri":"https://huayuye.github.io/blog/2021/11/mq-recovery-dets/","year":"2021"},{"content":"注解\nJDK1.5版本才有的，理解为元数据，即描述数据的数据。 注解里面没有业务逻辑。\n理解 注解是元数据，描述数据的数据 注解不涉及逻辑处理，用户可以根据注解来实现相应的逻辑。 注解也可以理解为一个特殊的类 注解可以替代xml来定义相应的数据（如bean），使得更简洁，减少xml的配置\n一、java元注解 1、元注解\n@Documented –注解是否将包含在JavaDoc中\n@Retention –什么时候使用该注解\n@Target –注解用于什么地方（类/方法/包/域）\n@Inherited – 是否允许子类继承该注解\n2、元注解中的属性\n（1）@Documented\n一个简单的Annotations标记注解，表示是否\t将注解信息添加在java文档中。\n（2）@Retention 定义该注解的生命周期。\nRetentionPolicy.SOURCE – 在编译阶段丢弃。\n这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。\nRetentionPolicy.CLASS – 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。\nRetentionPolicy.RUNTIME– 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。\n（3）@Target – 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。 以下是一些可用的参数。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。\nElementType.TYPE:用于描述类、接口或enum声明\nElementType.FIELD:用于描述实例变量\nElementType.METHOD\nElementType.PARAMETER\nElementType.CONSTRUCTOR\nElementType.LOCAL_VARIABLE\nElementType.ANNOTATION_TYPE 另一个注释\nElementType.PACKAGE 用于记录java文件的package信息\n（4）@Inherited – 定义该注释和子类的关系\n二、自定义注解 像在平时定义接口类时，interface前添加一个@，就会使之成为一个注解\n注解的属性类型支持： 基本数据类型，String,enum\n\t//接口，类,枚举 @Target({ElementType.TYPE,ElementType.METHOD}) //运行时仍然有效 @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { //属性定义方式：类似定义一个接口方法，接口名即属性名，使用defult赋默认值 String value() default \u0026quot;myAnnotation\u0026quot;; }  三、解析注解 利用反射解析并获取其中的内容\npackage com.test.annotation; @MyAnnotation(\u0026quot;testMyAnnotation\u0026quot;) public class AnnotationTest { public static void main(String[] args) throws NoSuchMethodException { MyAnnotation myAnnotation = AnnotationTest.class.getAnnotation(MyAnnotation.class); System.out.println(\u0026quot;testMyAnnotation = \u0026quot;+myAnnotation.value()); MyAnnotation myAnnotation2 = AnnotationTest.class.getMethod(\u0026quot;testMyAnnotation\u0026quot;,String.class).getAnnotation(MyAnnotation.class); System.out.println(\\\u0026quot;testMyAnnotationMethon = \u0026quot;+myAnnotation2.value()); } @MyAnnotation(\u0026quot;testMyAnnotationMethon\u0026quot;) public void testMyAnnotation(String str) throws NoSuchMethodException { System.out.println(\u0026quot;testMyAnnotation = \u0026quot;+str); } }  ","id":2,"section":"posts","summary":"注解 JDK1.5版本才有的，理解为元数据，即描述数据的数据。 注解里面没有业务逻辑。 理解 注解是元数据，描述数据的数据 注解不涉及逻辑处理，用户可","tags":["java"],"title":"Java Meta Annotation","uri":"https://huayuye.github.io/blog/2021/11/java-meta-annotation/","year":"2021"},{"content":"1、 jps 列出已装载的JVM 请参考文档。\n2、 jstack 打印线程堆栈信息 请参考文档。\n3、jstat JVM监控统计信息，包括类的加载和卸载情况，新生代和老年代的容量、使用情况等信息。 -class -compiler -gc -gccapacity -gccause -gcnew -gcnewcapacity -gcold -gcoldcapacity -gcpermcapacity -gcutil -printcompilation 请参考文档。\n4、jmap 打印JVM堆内对象情况 请参考文档） -dump:[live,]format=b,file=\u0026lt; filename\u0026gt; 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件。 -finalizerinfo 打印正等候回收的对象的信息。 -heap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况。 -histo[:live] 打印每个class的实例数目、内存占用、类全名信息。VM的内部类名字开头会加上前缀“”。如果live子参数加上后,只统计活的对象数量。\\n\\n -clstats 打印classload的信息。包含每个classloader的名字、活泼性、地址、父classloader和加载的class数量。 -F 在pid没有响应的时候强制使用-dump或者-histo参数。在这个模式下，live子参数无效。\n5、 jinfo jinfo可以输出并修改运行时的java 进程的opts。用处比较简单，用于输出JAVA系统参数及命令行参数。请参考文档。\n6、jconsole 一个java GUI监视工具，可以以图表化的形式显示各种数据。可通过远程连接监视远程的服务器VM。在cmd命令行里输入jconsole，选择进程就可以了。需要注意的就是在运行jconsole之前，必须要先设置环境变量DISPLAY，否则会报错误。 请参考文档。\n7、 jvisualvm jvisualvm同jconsole都是一个基于图形化界面的、可以查看本地及远程的JAVA GUI监控工具，Jvisualvm同jconsole的使用方式一样，直接在命令行打入Jvisualvm即可启动，不过Jvisualvm相比，界面更美观一些，数据更实时。请参考文档。\n8、jhat 用于对JAVA heap进行离线分析的工具，可以对不同虚拟机中导出的heap信息文件进行分析。请参考文档。\n9、jdb 用来对core文件和正在运行的Java进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和Sun studio里面所带的dbx非常相似，但jdb是专门用来针对Java应用程序的。现在应该说日常的开发中很少用到JDB了，因为现在的IDE已经帮我们封装好了，如使用ECLIPSE调用程序就是非常方便的，只要在非常特定的情况下可能会用到这个命令，如远程服务器的维护，没有IDE进行调试，那这个时候JDB应该可以帮上忙。请参考文档。\n10、jstatd jstatd是一个基于RMI（Remove Method Invocation）的服务程序，它用于监控基于HotSpot的JVM中资源的创建及销毁，并且提供了一个远程接口允许远程的监控工具连接到本地的JVM执行命令。 请参考文档。\n参考：http://blog.csdn.net/weitry/article/details/53284586\n","id":3,"section":"posts","summary":"1、 jps 列出已装载的JVM 请参考文档。 2、 jstack 打印线程堆栈信息 请参考文档。 3、jstat JVM监控统计信息，包括类的加载和卸载情况，新生代和老年","tags":["jdk"],"title":"Jdk Tool","uri":"https://huayuye.github.io/blog/2021/11/jdk-tool/","year":"2021"},{"content":"关于本人之前遇到的一个位运算问题，简单的作了下分析，如有错误，望指正。\n/** * 二进制 逢二进一 * 八进制 逢八进一 * 十进制 逢十进一 * 十六进制 逢十六进一 A(10) B(11) C(12) D(13) E(14) F(15) */ /** * 十进制 转 二进制 *将 十进制数 除以 2 ，取每次的余数 再将余数倒排 即为对应的二进制 */ /** * 十进制 转 八进制 * 将 十进制数 除以 8 ，取每次的余数 再将余数倒排 即为对应的八进制 */ /** * 十进制 转 十六进制 * 将 十进制数 除以 16 ，取每次的余数 再将余数倒排 即为对应的十六进制 */ /** * 二进制 转 十进制 * 将二进制的每个权重值 相加 即为十进制 * 如 1 0110-\u0026gt; 1*2^4+0*2^3+1*2^2+1*2^1+0*2^0 */ /** * 二进制 转 八进制 * 将二进制从右往左 每三位（权重值） 表示一位八进制数，不足时 空位补0 */ /** * 二进制 转 十六进制 * 将二进制从右往左 每四位（权重值） 表示一位十六进制数，不足时 空位补0 */ /** * 八进制 转 二进制 * 将每位八进制数 用三位二进制数（必须是三位，不足时，左边补0）表示 * 或将每位八进制数 除以2 取每次余数 再倒排 即为对应二进制数 */ /** * 八进制 转 十进制 * 将每位八进制数 按权重值 相加 即为对应的十进制 * 如 226 -\u0026gt; 2*8^2+2*8^1+6*8^0 */ /** * 八进制 转 十六进制 * 可借助 十进制 或者 二进制 过渡 */ /** * 十六进制 转 二进制 * 将每位十六进制数 用四位二进制数（必须是四位，不足时，左边补0）表示 * 或将每位十六进制数 除以2 取每次余数 再倒排 即为对应二进制数 * 96 -\u0026gt; 1001 0110 */ /** * 十六进制 转 十进制 * 将每位十六进制数 按权重值 相加 即为对应的十进制 * 如 96 -\u0026gt; 9*16^1+6*16^0 */ /** * 十六进制 转 八进制 * 可借助 十进制 或者 二进制 过渡 */ /** * * * 1byte = 8bit * char = 2byte * short = 2byte * int = 4byte * long = 8byte * */   public static void main(String[] args) { /** * byte 与 bit 结合位运算 获取 byte 中每一位bit 的表示情况 */ //1、接受字节流，获取每个字节中每一位的值（bit）: byte -\u0026gt; bite String str = \u0026quot;1234A\u0026quot;; // 49: 0011 0001 // 50: 0011 0010 // 0 0011 001 右移一位 // 00 0011 00 右移两位 // 000 0011 0 右移三位 // 0000 0011 右移四位 // 00000 001 右移五位 System.out.println(\u0026quot;bit -\u0026gt; byte = [\u0026quot; + Integer.parseInt(\u0026quot;00110010\u0026quot;,2) + \u0026quot;]\u0026quot;); for(byte b:str.getBytes()){ //取第一位的值 System.out.println(b+\u0026quot; \u0026amp; 1 = \u0026quot; + (b \u0026amp; 1)); //第二位 System.out.println(b+\u0026quot;\u0026gt;\u0026gt;1 \u0026amp; 1 = \u0026quot; + (b\u0026gt;\u0026gt;1 \u0026amp; 1) ); //第三位，以此类推 System.out.println(b+\u0026quot;\u0026gt;\u0026gt;2 \u0026amp; 1 = \u0026quot; + (b\u0026gt;\u0026gt;2 \u0026amp; 1) ); //第四位 System.out.println(b+\u0026quot;\u0026gt;\u0026gt;3 \u0026amp; 1 = \u0026quot; + (b\u0026gt;\u0026gt;3 \u0026amp; 1) ); //第五位 System.out.println(b+\u0026quot;\u0026gt;\u0026gt;4 \u0026amp; 1 = \u0026quot; + (b\u0026gt;\u0026gt;4 \u0026amp; 1)); //第六位 System.out.println(b+\u0026quot;\u0026gt;\u0026gt;5 \u0026amp; 1 = \u0026quot; + (b\u0026gt;\u0026gt;5 \u0026amp; 1)); //第七位 System.out.println(b+\u0026quot;\u0026gt;\u0026gt;6 \u0026amp; 1 = \u0026quot; + (b\u0026gt;\u0026gt;6 \u0026amp; 1)); //第八位 System.out.println(b+\u0026quot;\u0026gt;\u0026gt;7 \u0026amp; 1 = \u0026quot; + (b\u0026gt;\u0026gt;7 \u0026amp; 1)); } //2、bite -\u0026gt; byte,未考虑负数情况，主要以左起第一位区分：0正。负数时 结果=Integer.parseInt()-256 String[] bitArr = {\u0026quot;00110001\u0026quot;,\u0026quot;00110010\u0026quot;}; for(String bit : bitArr){ // bit -\u0026gt; byte System.out.println(bit+\u0026quot; -\u0026gt; byte = \u0026quot; + (byte)Integer.parseInt(bit,2));//2：说明要转换的bit是二进制，默认是十进制 //byte -\u0026gt; String System.out.println((byte)Integer.parseInt(bit,2)+\u0026quot;-\u0026gt;String = \u0026quot; + new String(new byte[]{(byte)Integer.parseInt(bit,2)}) ); } /** * 位 运算 * \u0026amp; | ^ ～ \u0026gt;\u0026gt; \u0026lt;\u0026lt; */ //1、异或：按位异或，不同得1，同得0 //两数交换:规则，两数异或后的结果再与其中一个数异或得到另一个数 int a=1,b=2; a = a^b; b = a^b; a = a^b; System.out.println(\u0026quot;a=1,b=2 -\u0026gt; a=\u0026quot;+a+\u0026quot;,b=\u0026quot;+b); //一个数与另一个数异或两次结果还是这个数 int a1=1,b1=2; System.out.println(\u0026quot;a1=1,b1=2;a1^b1^b1= -\u0026gt; \u0026quot;+(a1^b1^b1)); //2、\u0026amp; ：全为1得1，否则得0 //3、| ：有1则得1 //4、a\u0026gt;\u0026gt;n 左补n个0,缩小原来的2^n ,a = a/2^n int a4=16;//0001 0000 System.out.println(\u0026quot;a4\u0026gt;\u0026gt;2(0000 0100) = \u0026quot;+(a4\u0026gt;\u0026gt;2)); //5、a\u0026lt;\u0026lt;n 右补n个0，增大为原来的 2^n ,a = a*2^n int a5=2;//0000 0010 System.out.println(\u0026quot;a5\u0026lt;\u0026lt;2(0000 1000) = \u0026quot;+(a5\u0026lt;\u0026lt;2)); }  ","id":4,"section":"posts","summary":"关于本人之前遇到的一个位运算问题，简单的作了下分析，如有错误，望指正。 /** * 二进制 逢二进一 * 八进制 逢八进一 * 十进制 逢十进一 * 十六进制 逢十六进一","tags":["二进制"],"title":"Binary Convert(二进制之转换)","uri":"https://huayuye.github.io/blog/2021/11/binary-convert/","year":"2021"},{"content":"mybatis where 标签的一个小坑，被我踩下去了.\n为什么我会踩这个坑，只是因为我在模糊查询时，不想使用${},而使用另一个标签。\n标签的作用就是将 传过来的参数绑定到另一自定义的变量上去，然后方便使用 #{}获取\n问题 sql :\n\u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;keyword!=null\u0026quot;\u0026gt; \u0026lt;bind name=\u0026quot;likeKeyword\u0026quot; value=\u0026quot;keyword+'%'\u0026quot;\u0026gt;\u0026lt;/bind\u0026gt; and TaskNo like #{likeKeyword} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt;  当keyword不为null,sql中并不会自动去掉第一个and,导致sql报错。\n原因 and 前面还有内容(甚至不能有注释)\n解决方案：\n1、\n\u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;keyword!=null\u0026quot;\u0026gt; and TaskNo like concat(#{keyword},'%') \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt;  2、\n\u0026lt;where\u0026gt; \u0026lt;trim prefixOverrides=\u0026quot;and\u0026quot;\u0026gt; \u0026lt;if test=\u0026quot;keyword!=null\u0026quot;\u0026gt; \u0026lt;bind name=\u0026quot;likeKeyword\u0026quot; value=\u0026quot;keyword+'%'\u0026quot;\u0026gt;\u0026lt;/bind\u0026gt; and TaskNo like #{likeKeyword} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt;\t\u0026lt;/where\u0026gt;  ","id":5,"section":"posts","summary":"mybatis where 标签的一个小坑，被我踩下去了. 为什么我会踩这个坑，只是因为我在模糊查询时，不想使用${},而使用另一个标签。 标签的作用就是将 传过来的参数","tags":["mybatis"],"title":"Mybatis Where的坑","uri":"https://huayuye.github.io/blog/2021/11/mybatis-where/","year":"2021"},{"content":"之前因为每次idea加载项目都初始化index等时，gradle一致提示内存空间不足，于是就对gradle进行了配置\n配置 1、需要在gradle安装目录（如D:\\gradle）下的.gradle文件夹创建文件gradle.properties(如果存在就不用新建了)\n2、在文件中添加以下内容即可(内存分配大小自己决定)\n#开启线程守护，第一次编译时开线程，之后就不会再开了 org.gradle.daemon=true #配置编译时的虚拟机大小 org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 #开启并行编译，相当于多条线程再走 org.gradle.parallel=true #启用新的孵化模式 org.gradle.configureondemand=true  ","id":6,"section":"posts","summary":"之前因为每次idea加载项目都初始化index等时，gradle一致提示内存空间不足，于是就对gradle进行了配置 配置 1、需要在gradl","tags":["gradle"],"title":"Gradle Vm","uri":"https://huayuye.github.io/blog/2021/11/gradle-vm/","year":"2021"},{"content":"hello word !!!  编译 1、\n2、\n","id":7,"section":"posts","summary":"hello word !!! 编译 1、 2、","tags":null,"title":"Hello","uri":"https://huayuye.github.io/blog/2021/11/hello/","year":"2021"}],"tags":[{"title":"gradle","uri":"https://huayuye.github.io/blog/tags/gradle/"},{"title":"index","uri":"https://huayuye.github.io/blog/tags/index/"},{"title":"java","uri":"https://huayuye.github.io/blog/tags/java/"},{"title":"jdk","uri":"https://huayuye.github.io/blog/tags/jdk/"},{"title":"mq","uri":"https://huayuye.github.io/blog/tags/mq/"},{"title":"mybatis","uri":"https://huayuye.github.io/blog/tags/mybatis/"},{"title":"nginx","uri":"https://huayuye.github.io/blog/tags/nginx/"},{"title":"二进制","uri":"https://huayuye.github.io/blog/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]}